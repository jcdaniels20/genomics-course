---
title: 'Lab 4A: Introduction to R Graphics'
author: "Jarrod Daniels"
date: "9/14/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r library tidyverse}
library(tidyverse)
```

## Data Visualization with ggplot2


```{r read csv}
surveys_complete <- read_csv("data/surveys_complete.csv")
```
## Plotting with GGplot 2
ggplot2 is a plotting package that makes it simple to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. Therefore, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.

ggplot2 functions like data in the ‘long’ format, i.e., a column for every dimension, and a row for every observation. Well-structured data will save you lots of time when making figures with ggplot2

ggplot graphics are built step by step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots.

To build a ggplot, we will use the following basic template that can be used for different types of plots:

ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()

```{r graph 1}
ggplot(data = surveys_complete)
```

define an aesthetic mapping (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.

```{r graph 1-2}
ggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length))
```

add ‘geoms’ – graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; we will use some common ones today, including:

- geom_point() for scatter plots, dot plots, etc.
- geom_boxplot() for, well, boxplots!
- geom_line() for trend lines, time series, etc.

To add a geom to the plot use + operator. Because we have two continuous variables, let’s use geom_point() first:

```{r graph 1-3}

ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +
  geom_point()

```

The + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot “templates” and conveniently explore different types of plots, so the above plot can also be generated with code like this:

```{r graph 1-4}
# Assign plot to a variable
surveys_plot <- ggplot(data = surveys_complete, 
                       mapping = aes(x = weight, y = hindfoot_length))

# Draw the plot
surveys_plot + 
    geom_point()

```

# Notes
 - Anything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are universal plot settings). This includes the x- and y-axis you set up in aes().
 - You can also specify aesthetics for a given geom independently of the aesthetics defined globally in the ggplot() function.
 - The + sign used to add layers must be placed at the end of each line containing a layer. If, instead, the + sign is added in the line before the other layer, ggplot2 will not add the new layer and will return an error message.
 
```{r graph 1-5}
# This is the correct syntax for adding layers
surveys_plot +
  geom_point()

# This will not add the new layer and will return an error message
#surveys_plot
#  + geom_point()

```
 
## Challenge 1 

```{r Challenge 1}
library("hexbin")

surveys_plot +
 geom_hex()
```
Looking at the hexagonal model I believe its strength lies in the fact that you are able to visualize density (or areas with high density) quite well. As for its weakness however,I believe that this would not be good for looking at individual points over overall distribution

## Building your plots iteratively

Building plots with ggplot2 is typically an iterative process. We start by defining the dataset we’ll use, lay out the axes, and choose a geom:

```{r graph 2}
ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +
    geom_point()
```

Then, we start modifying this plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:

```{r graph 2-2}
ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) +
    geom_point(alpha = 0.1)
```

We can also add colors for all the points:
```{r graph 2-3}
ggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length)) +
    geom_point(alpha = 0.1, color = "blue")
```

Or to color each species in the plot differently, you could use a vector as an input to the argument color. ggplot2 will provide a different color corresponding to different values in the vector. Here is an example where we color with species_id:

```{r 2-4}
ggplot(data = surveys_complete, mapping = aes(x = weight, y = hindfoot_length)) +
    geom_point(alpha = 0.1, aes(color = species_id))
```

## Challenge 2

```{r 2-5}
ggplot(data = surveys_complete, 
       mapping = aes(x = species_id, y = weight)) +
   geom_point(aes(color = plot_type))
```

## Boplot

```{r graph 3}
ggplot(data = surveys_complete, mapping = aes(x = species_id, y = weight)) +
    geom_boxplot()

```
By adding points to the boxplot, we can have a better idea of the number of measurements and of their distribution:

```{r graph 3-2}
ggplot(data = surveys_complete, mapping = aes(x = species_id, y = weight)) +
    geom_boxplot(alpha = 0) +
    geom_jitter(alpha = 0.3, color = "tomato")
```

Notice how the boxplot layer is behind the jitter layer? What do you need to change in the code to put the boxplot in front of the points such that it’s not hidden?

## Challenge 3

```{r graph violin}
ggplot(data = surveys_complete, mapping = aes(x = species_id, y = weight)) +
    geom_violin()+scale_y_log10()

```

```{r graph boxplot 2}

surveys_complete$plot_id = factor(surveys_complete$plot_id)

ggplot(data = surveys_complete, mapping = aes(x = species_id, y = hindfoot_length)) +
    geom_boxplot(alpha = 0) +
    geom_jitter(alpha = 0.3, aes(color = plot_id))


```
If we change plot ID from an interger to a factor, the coloring on the graph becomes much more unique/visible rather than being a single light-dark blue gradient. 

